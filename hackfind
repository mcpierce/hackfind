#!/usr/bin/env python

from __future__ import print_function

import time
from datetime import datetime
import getopt, sys
import re
import GeoIP

class Country:
    """Represents a single country."""

    __instances = []
    __by_name = {}

    def __init__(self, name):
        self.__name = name
        self.__addresses = {}
        # keep track of all instances
        Country.__instances.append(self)
        Country.__by_name[name] = self

    def add_address(self, address):
        self.__addresses[address.address] = address

    @property
    def name(self):
        return self.__name if self.__name is not None else "Indeterminate"

    @property
    def raw_name(self):
        return self.__name

    @property
    def total_addresses(self):
        return len(self.__addresses)

    def for_address(self, address):
        return self.__addresses.get(address)

    @property
    def addresses(self):
        return self.__addresses

    @property
    def sorted_addresses(self):
        return sorted(self.__addresses.values(), key = lambda a: a.address)

    @property
    def oldest_attempt(self):
        return self._find_access_date(oldest = True)

    @property
    def newest_attempt(self):
        return self._find_access_date(oldest = False)

    @property
    def total_attempts(self):
        return reduce(lambda x, y: x + y.total_attempts, self.__addresses.values(), 0)

    @property
    def attack_ratio(self):
        return float(self.total_attempts) / float(self.total_addresses)

    def _find_access_date(self, oldest):
        result = None
        for address in self.__addresses.values():
            if oldest:
                if result is None or address.oldest_attempt < result:
                    result = address.oldest_attempt
            else:
                if result is None or address.latest_attempt > result:
                    result = address.latest_attempt
        return result[0]

    @classmethod
    def get_top_offenders(cls, size=5):
        """Returns the top offenders, up to size in number."""
        return sorted(cls.__instances, key = lambda a: a.total_attempts, reverse=True)[:size]

    @classmethod
    def get_instances(cls):
        return cls.__instances

    @classmethod
    def for_name(cls, name):
        return cls.__by_name.get(name)

    @classmethod
    def by_name(cls):
        return sorted(cls.__instances, key = lambda a: a.name)

class Address:
    """Represents a single IP address."""

    def __init__(self, address):
        self.__address = address
        self.__attempts = [] # (date, port)

    def add_attempt(self, date, port):
        self.__attempts.append([date, port])

    @property
    def address(self):
        return self.__address

    @property
    def attempts(self):
        return self.__attempts

    @property
    def oldest_attempt(self):
        return sorted(self.__attempts)[0]

    @property
    def latest_attempt(self):
        return sorted(self.__attempts)[-1]

    @property
    def total_attempts(self):
        return len(self.__attempts)

    @property
    def attempts_sorted_by_date(self):
        return sorted(self.__attempts, key=lambda attempt: attempt[0])

GI = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
TOTALS = {}

IP_RE = "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
default_timestamp_re = re.compile("(Sun|Mon|Tue|Wed|Thu|Fri|Sat), (.+) (.+) (.+) (.+) (.+) \(PST\)$")
access_attempt_re = re.compile("\[LAN access from remote] from (%s)" % IP_RE)
access_attempt_with_datetime_re = re.compile("\[LAN access from remote] from (%s):\d+ to %s:\d+, (Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday), (.*)" % (IP_RE, IP_RE))

default_datetime = ""

def get_timestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y %H:%M:%S")

def get_datestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y")

def get_month_and_year(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%Y")

def get_number_of_days(newest, oldest):
    return (datetime.utcfromtimestamp(newest) - datetime.utcfromtimestamp(oldest)).days

def show_output(text):
    print("%s | %s" % (get_timestamp(time.time()), text))

def debug(text):
    if DEBUG: show_output(text)

def usage():
    print("USAGE: hackfind -i INFILE -o OUTFILE [-v | --verbose] [-h | --help]\n")
    print("  INFILE  - the router log file")
    print("  OUTFILE - the report file")
    print("\nOPTIONS:")
    print("  -v, --verbose\t show verbose output (def. off)")
    print("  -h, --help   \t show this help information")

def convert_month_first(timestamp):
    return time.mktime(datetime.strptime(timestamp, "%B %d, %Y %H:%M:%S").timetuple())

def get_default_datetime(line):
    # match = re.search(DEFAULT_TIMESTAMP_RE, line)
    match = default_timestamp_re.search(line)
    global default_datetime
    line = "%s %s %s %s" % (match.group(2), match.group(3), match.group(4), match.group(5))
    default_datetime = time.mktime(datetime.strptime(line, "%d %b %Y %H:%M:%S").timetuple())

def store_access_detail(geoip, source, when):
    # get the country's details, then get the source IP address's details
    country = Country.for_name(geoip)
    if country is None:
        country = Country(geoip)
    address = country.for_address(source)
    if address is None:
        address = Address(source)
        country.add_address(address)
    address.add_attempt(when, 22) # TODO: Fix the port being accessed

    # if we're doing totals, then add them
    if len(tfile) > 0:
        date = get_month_and_year(when)
        record = TOTALS.get(date)
        if record is None:
            record = 0
            TOTALS[date] = record
        record = record + 1
        TOTALS[date] = record

def get_access_source(line):
    # return from any P2P access attempts
    if re.search(r':52017', line): return
    # first see if we have a datetime entry
    match = access_attempt_with_datetime_re.search(line)
    if match:
        source = match.group(1)
        when = convert_month_first(match.group(3))
    else:
        match = access_attempt_re.search(line)
        source = match.group(1)
        when = default_datetime
    # get the geoip information for the source
    geoip = GI.country_name_by_addr(source)
    store_access_detail(geoip, source, when)

def process_line(line):
    line = line.strip("\r\n")
    debug("read=%s" % line)
    # if the line contains "(PST)" then it has a default date stamp
    # if re.search(DEFAULT_TIMESTAMP_RE, line):
    if default_timestamp_re.search(line):
        get_default_datetime(line)
    elif access_attempt_re.search(line):
        get_access_source(line)

def update_top_offenders(top_offenders_list, count, country):
    # find a country with fewer offenses and insert the supplied country
    index = 0
    while top_offenders_list[index] is not None and top_offenders_list[index][0] >= count and index < len(top_offenders_list):
        print("Updating %d for %s (%d)" % (index, country, count))
        index = index + 1
    if index < len(top_offenders_list):
        current = len(top_offenders_list) - 1
        while current > index and current > 1:
            top_offenders_list[current] = top_offenders_list[current - 1]
            current = current - 1
        print("Inserting %s at %d" % (country, index))
        top_offenders_list[index] = [count, country]
        

ofile = cfile = tfile = None

try:
    opts, args = getopt.getopt(sys.argv[1:], "i:o:c:t:vh",
                               [
                                   "input=",
                                   "output=",
                                   "totals=",
                                   "csv=",
                                   "verbose",
                                   "help"
                               ])
except getopt.GetoptError as err:
    print(str(err))
    usage()
    sys.exit(2)

# define values
DEBUG=False

for o, a in opts:
    if o == "-v":
        DEBUG = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit(0)
    elif o in ("-i", "--input"):
        ifile = a
    elif o in ("-o", "--output"):
        ofile = a
    elif o in ("-c", "--csv"):
        cfile = a
    elif o in ("-t", "--totals"):
        tfile = a
    else:
        assert False, "invalid option: %s" % o

debug("USING: ifile=%s" % ifile)

if len(ifile) == 0:
    die("missing or invalid filename: %s" % ifile)

# the ifile is read and processed into a hash
#
# the key is the source IP address
# the value an array
#
# the value array has two elements:
# * the country of origin for the IP address, and
# * the date and time of the access attempt

results = {}

show_output("Loading file: %s" % ifile)

with open(ifile) as f:
    lines = f.readlines()
    for line in lines:
        process_line(line)

old_stdout = sys.stdout
most_attempts = [0, None]
single_most_attempts = [0, None, None]
longest_running_attempts = [0, None, None, None, None]
oldest = newest = None
top_offenders = [None, None, None, None, None]

if len(ofile) > 0:
    show_output("Writing to %s" % ofile)
    sys.stdout = open(ofile, "w")

for country in Country.by_name():
    print("COUNTRY: %s" % country.name)
    print("         Total addresses..: %d" % country.total_addresses)
    print("         Total attempts...: %d" % country.total_attempts)
    print("")
    for address in sorted(country.sorted_addresses):
        address_oldest = address.oldest_attempt
        address_newest = address.latest_attempt
        if get_number_of_days(address_newest[0], address_oldest[0]) > longest_running_attempts[0]:
            longest_running_attempts = (get_number_of_days(address_newest[0], address_oldest[0]),
                                        address.total_attempts, address, country,
                                        get_datestamp(address_oldest[0]),
                                        get_datestamp(address_newest[0]))
        print("")
        print("IP ADDRESS: %s [%d attempt(s)] from %s to %s" % (address.address, address.total_attempts, get_datestamp(address_oldest[0]), get_datestamp(address_newest[0])))
        print("  DATE OF ACCESS    PORT#    DATE OF ACCESS    PORT#    DATE OF ACCESS    PORT#")
        print("=================== =====  =================== =====  =================== =====")
        which = 0
        for attempt in address.attempts:
            if which in [1, 2]:
                print("  ", end='')
            print("%19s %5d" % (get_timestamp(attempt[0]), attempt[1]), end='')
            which = which + 1
            if which is 3:
                print("")
                which = 0
        print("")
    print("")
    print("")
    print("")
    print("")
print("")
print("===== Top %d offending countries (by access attempts)" % len(top_offenders))
for offender in Country.get_top_offenders():
    if offender is not None:
        print("      %40s: %5d attempts   %3d addresses   Ratio=%0.3f)" % (offender.name, offender.total_attempts, offender.total_addresses, offender.attack_ratio))
print("")
print("Country totals:")
print("                  COUNTRY                 ADDRS  TOTAL    OLDEST      NEWEST    # DAYS")
print("========================================  =====  =====  ==========  ==========  ======")
for country in sorted(Country.get_instances(), key = lambda x: x.raw_name):
    print("%-40s  %5d  %5d  %s  %s  %6s" % (country.name, country.total_addresses, country.total_attempts, get_datestamp(country.oldest_attempt), get_datestamp(country.newest_attempt), get_number_of_days(country.newest_attempt, country.oldest_attempt)))

sys.stdout.close()

sys.stdout = old_stdout

if len(cfile) > 0:
    show_output("Writing CSV file: %s" % cfile)

    sys.stdout = open(cfile, "w")
    print("\"DATE\",\"COUNTRY\",\"IP ADDRESS\"")
    for country in Country.by_name():
        for address in country.sorted_addresses:
            for detail in address.attempts_sorted_by_date:
                print("\"%s\",\"%s\",\"%s\"" % (get_timestamp(detail[0]), country, address))
    sys.stdout.close()
    sys.stdout = old_stdout

if len(tfile) > 0:
    show_output("Writing totals file: %s" % tfile)

    sys.stdout = open(tfile, "w")
    print("\"DATE\",\"ATTEMPTS\"")
    for date in sorted(TOTALS.keys()):
        record = TOTALS.get(date)
        print("\"%s\",\"%s\"" % (date, record))
    sys.stdout.close()
    sys.stdout = old_stdout

show_output("Finished!")
