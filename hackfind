#!/usr/bin/env python

import time
from datetime import datetime
import getopt, sys
import re
import GeoIP

GI = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
DETAILS = {}

IP_RE = "\d+\.\d+\.\d+\.\d+"
default_timestamp_re = re.compile("(Sun|Mon|Tue|Wed|Thu|Fri|Sat), (.+) (.+) (.+) (.+) (.+) \(PST\)$")
access_attempt_re = re.compile("\[LAN access from remote] from (%s)" % IP_RE)
access_attempt_with_datetime_re = re.compile("\[LAN access from remote] from (%s):\d+ to %s:\d+, (Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday), (.*)" % (IP_RE, IP_RE))

default_datetime = ""

def get_timestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y %H:%M:%S")

def get_datestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y")

def get_number_of_days(newest, oldest):
    return (datetime.utcfromtimestamp(newest) - datetime.utcfromtimestamp(oldest)).days

def show_output(text):
    print "%s | %s" % (get_timestamp(time.time()), text)

def debug(text):
    if DEBUG: show_output(text)

def usage():
    print "USAGE: hackfind -i INFILE -o OUTFILE [-v | --verbose] [-h | --help]\n"
    print "  INFILE  - the router log file"
    print "  OUTFILE - the report file"
    print "\nOPTIONS:"
    print "  -v, --verbose\t show verbose output (def. off)"
    print "  -h, --help   \t show this help information"

def convert_month_first(timestamp):
    return time.mktime(datetime.strptime(timestamp, "%B %d, %Y %H:%M:%S").timetuple())

def get_default_datetime(line):
    # match = re.search(DEFAULT_TIMESTAMP_RE, line)
    match = default_timestamp_re.search(line)
    global default_datetime
    line = "%s %s %s %s" % (match.group(2), match.group(3), match.group(4), match.group(5))
    default_datetime = time.mktime(datetime.strptime(line, "%d %b %Y %H:%M:%S").timetuple())

def store_access_detail(geoip, source, when):
    # get the country's details, then get the source IP address's details
    # DETAILS[country] = {source => [when0, when1, ..., whenn]}
    country = DETAILS.get(geoip)
    if country is None:
        country = {}
        DETAILS[geoip] = country
    for_address = country.get(source)
    if for_address is None:
        for_address = []
        country[source] = for_address
    for_address.append(when)

def get_access_source(line):
    # return from any P2P access attempts
    if re.search(r':52017', line): return
    # first see if we have a datetime entry
    match = access_attempt_with_datetime_re.search(line)
    if match:
        source = match.group(1)
        when = convert_month_first(match.group(3))
    else:
        match = access_attempt_re.search(line)
        source = match.group(1)
        when = default_datetime
    # get the geoip information for the source
    geoip = GI.country_name_by_addr(source)
    store_access_detail(geoip, source, when)

def process_line(line):
    line = line.strip("\r\n")
    debug("read=%s" % line)
    # if the line contains "(PST)" then it has a default date stamp
    # if re.search(DEFAULT_TIMESTAMP_RE, line):
    if default_timestamp_re.search(line):
        get_default_datetime(line)
    elif access_attempt_re.search(line):
        get_access_source(line)
        

ofile = cfile = None

try:
    opts, args = getopt.getopt(sys.argv[1:], "i:o:c:vh",
                               [
                                   "input=",
                                   "output=",
                                   "csv=",
                                   "verbose",
                                   "help"
                               ])
except getopt.GetoptError as err:
    print str(err)
    usage()
    sys.exit(2)

# define values
DEBUG=False

for o, a in opts:
    if o == "-v":
        DEBUG = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit(0)
    elif o in ("-i", "--input"):
        ifile = a
    elif o in ("-o", "--output"):
        ofile = a
    elif o in ("-c", "--csv"):
        cfile = a
    else:
        assert False, "invalid option: %s" % o

debug("USING: ifile=%s" % ifile)

if len(ifile) == 0:
    die("missing or invalid filename: %s" % ifile)

# the ifile is read and processed into a hash
#
# the key is the source IP address
# the value an array
#
# the value array has two elements:
# * the country of origin for the IP address, and
# * the date and time of the access attempt

results = {}

show_output("Loading file: %s" % ifile)

with open(ifile) as f:
    lines = f.readlines()
    for line in lines:
        process_line(line)

old_stdout = sys.stdout
access_count = 0
most_attempts = [0, None]
single_most_attempts = [0, None, None]
oldest = newest = None
accesses = []

if len(ofile) > 0:
    sys.stdout = open(ofile, "w")
    show_output("Writing to %s" % ofile)

for country in sorted(DETAILS.keys()):
    access_by_country = 0
    country_oldest = country_newest = None
    country_details = DETAILS.get(country)
    print "===== COUNTRY: %s (total addresses found=%d)" % (country, len(country_details))
    for address in sorted(country_details.keys()):
        address_details = country_details.get(address)
        if len(address_details) > single_most_attempts[0]:
            single_most_attempts = (len(address_details), address, country)
        print ""
        print "IP ADDRESS: %s [%d attempt(s)]" % (address, len(address_details))
        print "SOURCE ADDRESS  DATE OF ACCESS"
        print "=============== ==================="
        for detail in sorted(address_details):
            if oldest is None or detail < oldest:
                oldest = detail
            if country_oldest is None or detail < country_oldest:
                country_oldest = detail
            if newest is None or newest < detail:
                newest = detail
            if country_newest is None or country_newest < detail:
                country_newest = detail
            print "%15s %s" % (address, get_timestamp(detail))
        access_count = access_count + len(address_details)
        access_by_country = access_by_country + len(address_details)
    if access_by_country > most_attempts[0]:
        most_attempts = (access_by_country, country)
    accesses.append((country, len(country_details), access_by_country, get_datestamp(country_oldest), get_datestamp(country_newest), get_number_of_days(country_newest, country_oldest)))
    print ""
    print "TOTAL ATTEMPTS: %d" % access_by_country
    print ""
print ""
print "===== Total records: %d" % access_count
print "===== Most attempts (%d total) from country %s" % most_attempts
print "===== Most attempts (%d total) from address %s (%s)" % single_most_attempts
print "===== Oldest record: %s" % get_timestamp(oldest)
print "===== Newest record: %s (a span of %d days)" % (get_timestamp(newest), get_number_of_days(newest, oldest))
print ""
print "Country totals:"
print "                  COUNTRY                 ADDRS  TOTAL    OLDEST      NEWEST    # DAYS"
print "========================================  =====  =====  ==========  ==========  ======"
for access in accesses:
    print "%-40s  %5d  %5d  %s  %s %6s" % access

sys.stdout.close()

sys.stdout = old_stdout

if len(cfile) > 0:
    show_output("Writing CSV file: %s" % cfile)

    sys.stdout = open(cfile, "w")
    for country in sorted(DETAILS.keys()):
        country_details = DETAILS.get(country)
        for address in sorted(country_details.keys()):
            address_details = country_details.get(address)
            for detail in sorted(address_details):
                print "\"%s\",\"%s\",\"%s\"" % (country, address, get_timestamp(detail))
    sys.stdout.close()
    sys.stdout = old_stdout

show_output("Finished!")
