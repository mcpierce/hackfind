#!/usr/bin/env python

from __future__ import print_function

import time
from datetime import datetime
import getopt, sys
import re
import GeoIP

class Country:
    """Represents a single country."""

    __instances = []
    __by_name = {}

    def __init__(self, name):
        self.__name = name
        self.__addresses = {}
        # keep track of all instances
        Country.__instances.append(self)
        Country.__by_name[name] = self

    def add_address(self, address):
        self.__addresses[address.address] = address

    @property
    def name(self):
        return self.__name if self.__name is not None else "Indeterminate"

    @property
    def raw_name(self):
        return self.__name

    @property
    def total_addresses(self):
        return len(self.__addresses)

    def for_address(self, address):
        return self.__addresses.get(address)

    @property
    def addresses(self):
        return self.__addresses

    @property
    def sorted_addresses(self):
        return sorted(self.__addresses.values(), key = lambda a: a.address)

    @property
    def oldest_attempt(self):
        return self._find_access_date(oldest = True)

    @property
    def newest_attempt(self):
        return self._find_access_date(oldest = False)

    @property
    def total_attempts(self):
        return reduce(lambda x, y: x + y.total_attempts, self.__addresses.values(), 0)

    @property
    def attack_ratio(self):
        return float(self.total_attempts) / float(self.total_addresses)

    def _find_access_date(self, oldest):
        result = None
        for address in self.__addresses.values():
            if oldest:
                if result is None or address.oldest_attempt < result:
                    result = address.oldest_attempt
            else:
                if result is None or address.newest_attempt > result:
                    result = address.newest_attempt
        return result[0]

    @classmethod
    def get_top_offenders(cls, size=5):
        """Returns the top offenders, up to size in number."""
        return sorted(cls.__instances, key = lambda a: a.total_attempts, reverse=True)[:size]

    @classmethod
    def get_instances(cls):
        return cls.__instances

    @classmethod
    def for_name(cls, name):
        return cls.__by_name.get(name)

    @classmethod
    def by_name(cls):
        return sorted(cls.__instances, key = lambda a: a.name)

class Address:
    """Represents a single IP address."""

    __instances = []

    def __init__(self, address):
        self.__address = address
        self.__attempts = [] # (date, port)
        Address.__instances.append(self)

    def add_attempt(self, date, port):
        self.__attempts.append([date, port])

    @property
    def address(self):
        return self.__address

    @property
    def attempts(self):
        return self.__attempts

    @property
    def oldest_attempt(self):
        return sorted(self.__attempts)[0]

    @property
    def newest_attempt(self):
        return sorted(self.__attempts)[-1]

    @property
    def total_attempts(self):
        return len(self.__attempts)

    @property
    def attempts_sorted_by_date(self):
        return sorted(self.__attempts, key=lambda attempt: attempt[0])

    @classmethod
    def overall_oldest_attempt(cls):
        result = None
        for address in cls.__instances:
            if result is None or address.oldest_attempt[0] < result:
                result = address.oldest_attempt[0]
        return result

    @classmethod
    def overall_newest_attempt(cls):
        result = None
        for address in cls.__instances:
            if result is None or address.newest_attempt[0] > result:
                result = address.newest_attempt[0]
        return result

GI = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
TOTALS = {}

IP_RE = "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
default_timestamp_re = re.compile("(Sun|Mon|Tue|Wed|Thu|Fri|Sat), (.+) (.+) (.+) (.+) (.+) \(PST\)$")
access_attempt_re = re.compile("\[LAN access from remote] from (%s):(\d{1,5})" % IP_RE)
access_attempt_with_datetime_re = re.compile("\[LAN access from remote] from (%s):\d+ to (%s):(\d+), (Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday), (.*)" % (IP_RE, IP_RE))

default_datetime = ""

def get_timestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y %H:%M:%S")

def get_datestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y")

def get_month_and_year(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%Y")

def get_number_of_days(newest, oldest):
    return (datetime.utcfromtimestamp(newest) - datetime.utcfromtimestamp(oldest)).days

def show_output(text):
    print("%s | %s" % (get_timestamp(time.time()), text))

def debug(text):
    if DEBUG: show_output(text)

def verbose(text):
    if VERBOSE: show_output(text)

def usage():
    print("USAGE: hackfind -i INFILE -o OUTFILE OPTIONS\n")
    print("  INFILE  - the router log file")
    print("  OUTFILE - the report file")
    print("\nOPTIONS:")
    print("  -a, --allports     include all ports")
    print("  -p, --port=[PORT]  include attempts that target PORT")
    print(" --includeweb        include attempts to port 80, 443")
    print(" --includep2p        include attempts to port 52017")
    print(" --totals            only report totals")
    print("  -v, --verbose      show verbose output (def. off)")
    print("  -h, --help         show this help information")

def convert_month_first(timestamp):
    return time.mktime(datetime.strptime(timestamp, "%B %d, %Y %H:%M:%S").timetuple())

def get_default_datetime(line):
    # match = re.search(DEFAULT_TIMESTAMP_RE, line)
    match = default_timestamp_re.search(line)
    global default_datetime
    line = "%s %s %s %s" % (match.group(2), match.group(3), match.group(4), match.group(5))
    default_datetime = time.mktime(datetime.strptime(line, "%d %b %Y %H:%M:%S").timetuple())

def store_access_detail(geoip, source, port, when):
    # get the country's details, then get the source IP address's details
    country = Country.for_name(geoip)
    if country is None:
        country = Country(geoip)
    address = country.for_address(source)
    if address is None:
        address = Address(source)
        country.add_address(address)
    address.add_attempt(when, port)

    # if we're doing totals, then add them
    if tfile is not None and len(tfile) > 0:
        date = get_month_and_year(when)
        record = TOTALS.get(date)
        if record is None:
            record = 0
            TOTALS[date] = record
        record = record + 1
        TOTALS[date] = record

def get_access_source(line):
    # first see if we have a datetime entry
    match = access_attempt_with_datetime_re.search(line)
    if match:
        source = match.group(1)
        port = int(match.group(3))
        when = convert_month_first(match.group(5))
    else:
        match = access_attempt_re.search(line)
        source = match.group(1)
        port = int(match.group(2))
        when = default_datetime

    # if the port isn't included then return
    if not ALLPORTS and port not in include_ports:
        verbose("Ignoring port %d" % port)
        return

    # get the geoip information for the source
    geoip = GI.country_name_by_addr(source)
    store_access_detail(geoip, source, port, when)

def process_line(line):
    line = line.strip("\r\n")
    debug("read=%s" % line)
    # if the line contains "(PST)" then it has a default date stamp
    # if re.search(DEFAULT_TIMESTAMP_RE, line):
    if default_timestamp_re.search(line):
        get_default_datetime(line)
    elif access_attempt_re.search(line):
        get_access_source(line)

def update_top_offenders(top_offenders_list, count, country):
    # find a country with fewer offenses and insert the supplied country
    index = 0
    while top_offenders_list[index] is not None and top_offenders_list[index][0] >= count and index < len(top_offenders_list):
        print("Updating %d for %s (%d)" % (index, country, count))
        index = index + 1
    if index < len(top_offenders_list):
        current = len(top_offenders_list) - 1
        while current > index and current > 1:
            top_offenders_list[current] = top_offenders_list[current - 1]
            current = current - 1
        print("Inserting %s at %d" % (country, index))
        top_offenders_list[index] = [count, country]
        
def generate_full_access_report():
    longest_running_attempts = [0, None, None, None, None]
    
    for country in Country.by_name():
        print("COUNTRY: %s" % country.name)
        print("         Total addresses..: %d" % country.total_addresses)
        print("         Total attempts...: %d" % country.total_attempts)
        print("")
        for address in sorted(country.sorted_addresses):
            address_oldest = address.oldest_attempt
            address_newest = address.newest_attempt
            if get_number_of_days(address_newest[0], address_oldest[0]) > longest_running_attempts[0]:
                longest_running_attempts = (get_number_of_days(address_newest[0], address_oldest[0]),
                                            address.total_attempts, address, country,
                                            get_datestamp(address_oldest[0]),
                                            get_datestamp(address_newest[0]))
            print("")
            print("IP ADDRESS: %s [%d attempt(s)] from %s to %s" % (address.address, address.total_attempts, get_datestamp(address_oldest[0]), get_datestamp(address_newest[0])))
            print("  DATE OF ACCESS    PORT#    DATE OF ACCESS    PORT#    DATE OF ACCESS    PORT#")
            print("=================== =====  =================== =====  =================== =====")
            which = 0
            for attempt in address.attempts:
                if which in [1, 2]:
                    print("  ", end='')
                print("%19s %5d" % (get_timestamp(attempt[0]), attempt[1]), end='')
                which = which + 1
                if which is 3:
                    print("")
                    which = 0
        print("")
        print("")
        print("")
        print("")
        print("")
        print("")
    print("===== Top %d offending countries (by access attempts)" % len(Country.get_top_offenders()))
    for offender in Country.get_top_offenders():
        if offender is not None:
            print("      %40s: %5d attempts   %3d addresses   Ratio=%0.3f)" % (offender.name, offender.total_attempts, offender.total_addresses, offender.attack_ratio))
    print("")

def generate_totals_report():
    old_stdout = sys.stdout
    if len(ofile) > 0:
        show_output("Writing to %s" % ofile)
        sys.stdout = open(ofile, "w")

    if not TOTALS_ONLY:
        generate_full_access_report()

    print("Country totals:")
    print("                  COUNTRY                 ADDRS  TOTAL    OLDEST      NEWEST    # DAYS")
    print("========================================  =====  =====  ==========  ==========  ======")
    for country in sorted(Country.get_instances(), key = lambda x: x.raw_name):
        print("%-40s  %5d  %5d  %s  %s  %6s" % (country.name, country.total_addresses, country.total_attempts, get_datestamp(country.oldest_attempt), get_datestamp(country.newest_attempt), get_number_of_days(country.newest_attempt, country.oldest_attempt)))

    if len(ofile) > 0:
        sys.stdout.close()
        sys.stdout = old_stdout

def generate_cvs_report():
    show_output("Writing CSV file: %s" % cfile)

    old_stdout = sys.stdout
    sys.stdout = open(cfile, "w")
    print("\"DATE\",\"COUNTRY\",\"IP ADDRESS\"")
    for country in Country.by_name():
        for address in country.sorted_addresses:
            for detail in address.attempts_sorted_by_date:
                print("\"%s\",\"%s\",\"%s\"" % (get_timestamp(detail[0]), country, address))
    sys.stdout.close()
    sys.stdout = old_stdout

ofile = cfile = tfile = None
include_web = False
include_p2p = False
include_ports = [22]

try:
    opts, args = getopt.getopt(sys.argv[1:], "i:o:c:tp:avdh",
                               [
                                   "input=",
                                   "output=",
                                   "totals=",
                                   "csv=",
                                   "includeweb",
                                   "includep2p",
                                   "port=",
                                   "allports",
                                   "verbose",
                                   "debug",
                                   "help"
                               ])
except getopt.GetoptError as err:
    print(str(err))
    usage()
    sys.exit(2)

# define values
DEBUG=False
VERBOSE=False
ALLPORTS=False
CREATE_CVS_FILE=False
TOTALS_ONLY=False

for o, a in opts:
    if o == "-v":
        VERBOSE = True
    elif o == "-d":
        DEBUG = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit(0)
    elif o in ("-i", "--input"):
        ifile = a
    elif o in ("-o", "--output"):
        ofile = a
    elif o in ("-c", "--csv"):
        cfile = a
        CREATE_CVS_FILE = True
    elif o in ("-t", "--totals"):
        TOTALS_ONLY = True
    elif o in ("--includeweb"):
        include_web = True
    elif o in ("--includep2p"):
        include_p2p = True
    elif o in ("-p", "--port"):
        include_ports.append(int(a))
    elif o in ("-a", "--allports"):
        ALLPORTS = True
    else:
        assert False, "invalid option: %s" % o

if include_web:
    include_ports.append(80)
    include_ports.append(443)
if include_p2p:
    include_ports.append(52017)

verbose("USING: ifile=%s" % ifile)

if len(ifile) == 0:
    die("missing or invalid filename: %s" % ifile)

# the ifile is read and processed into a hash
#
# the key is the source IP address
# the value an array
#
# the value array has two elements:
# * the country of origin for the IP address, and
# * the date and time of the access attempt

results = {}

show_output("Loading file: %s" % ifile)

with open(ifile) as f:
    lines = f.readlines()
    for line in lines:
        process_line(line)

generate_totals_report()
if CREATE_CVS_FILE: generate_cvs_report()

show_output("Finished!")
