#!/usr/bin/env python

import time
from datetime import datetime
import getopt, sys
import re
import GeoIP

class Country:
    """Represents a single country."""

    __instances = []
    __by_name = {}

    def __init__(self, name):
        self.__name = name
        self.__addresses = {}
        # keep track of all instances
        Country.__instances.append(self)
        Country.__by_name[name] = self

    def add_address(self, address):
        self.__addresses[address.address] = address

    @property
    def name(self):
        return self.__name if self.__name is not None else "Indeterminate"

    @property
    def raw_name(self):
        return self.__name

    @property
    def total_addresses(self):
        return len(self.__addresses)

    def for_address(self, address):
        return self.__addresses.get(address)

    @property
    def addresses(self):
        return self.__addresses

    @property
    def sorted_addresses(self):
        return sorted(self.__addresses.values(), key = lambda a: a.address)

    @property
    def oldest_attempt(self):
        return self._find_access_date(oldest = True)

    @property
    def newest_attempt(self):
        return self._find_access_date(oldest = False)

    @property
    def total_attempts(self):
        return reduce(lambda x, y: x + y.total_attempts, self.__addresses.values(), 0)

    @property
    def attack_ratio(self):
        return float(self.total_attempts) / float(self.total_addresses)

    def _find_access_date(self, oldest):
        result = None
        for address in self.__addresses.values():
            if oldest:
                if result is None or address.oldest_attempt < result:
                    result = address.oldest_attempt
            else:
                if result is None or address.latest_attempt > result:
                    result = address.latest_attempt
        return result[0]

    @classmethod
    def get_top_offenders(cls, size=5):
        """Returns the top offenders, up to size in number."""
        return sorted(cls.__instances, key = lambda a: a.total_attempts, reverse=True)[:size]

    @classmethod
    def get_instances(cls):
        return cls.__instances

    @classmethod
    def for_name(cls, name):
        return cls.__by_name.get(name)

    @classmethod
    def by_name(cls):
        return sorted(cls.__instances, key = lambda a: a.name)

class Address:
    """Represents a single IP address."""

    def __init__(self, address):
        self.__address = address
        self.__attempts = [] # (date, port)

    def add_attempt(self, date, port):
        self.__attempts.append([date, port])

    @property
    def address(self):
        return self.__address

    @property
    def attempts(self):
        return self.__attempts

    @property
    def oldest_attempt(self):
        return sorted(self.__attempts)[0]

    @property
    def latest_attempt(self):
        return sorted(self.__attempts)[-1]

    @property
    def total_attempts(self):
        return len(self.__attempts)

    @property
    def attempts_sorted_by_date(self):
        return sorted(self.__attempts, key=lambda attempt: attempt[0])

GI = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
DETAILS = {}
TOTALS = {}

IP_RE = "\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
default_timestamp_re = re.compile("(Sun|Mon|Tue|Wed|Thu|Fri|Sat), (.+) (.+) (.+) (.+) (.+) \(PST\)$")
access_attempt_re = re.compile("\[LAN access from remote] from (%s)" % IP_RE)
access_attempt_with_datetime_re = re.compile("\[LAN access from remote] from (%s):\d+ to %s:\d+, (Sunday|Monday|Tuesday|Wednesday|Thursday|Friday|Saturday), (.*)" % (IP_RE, IP_RE))

default_datetime = ""

def get_timestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y %H:%M:%S")

def get_datestamp(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%d/%Y")

def get_month_and_year(timestamp):
    return datetime.fromtimestamp(int(timestamp)).strftime("%m/%Y")

def get_number_of_days(newest, oldest):
    return (datetime.utcfromtimestamp(newest) - datetime.utcfromtimestamp(oldest)).days

def show_output(text):
    print "%s | %s" % (get_timestamp(time.time()), text)

def debug(text):
    if DEBUG: show_output(text)

def usage():
    print "USAGE: hackfind -i INFILE -o OUTFILE [-v | --verbose] [-h | --help]\n"
    print "  INFILE  - the router log file"
    print "  OUTFILE - the report file"
    print "\nOPTIONS:"
    print "  -v, --verbose\t show verbose output (def. off)"
    print "  -h, --help   \t show this help information"

def convert_month_first(timestamp):
    return time.mktime(datetime.strptime(timestamp, "%B %d, %Y %H:%M:%S").timetuple())

def get_default_datetime(line):
    # match = re.search(DEFAULT_TIMESTAMP_RE, line)
    match = default_timestamp_re.search(line)
    global default_datetime
    line = "%s %s %s %s" % (match.group(2), match.group(3), match.group(4), match.group(5))
    default_datetime = time.mktime(datetime.strptime(line, "%d %b %Y %H:%M:%S").timetuple())

def store_access_detail(geoip, source, when):
    # get the country's details, then get the source IP address's details
    # DETAILS[country] = {source => [when0, when1, ..., whenn]}
    country = DETAILS.get(geoip)
    if country is None:
        country = Country(geoip)
        DETAILS[geoip] = country
    address = country.for_address(source)
    if address is None:
        address = Address(source)
        country.add_address(address)
    address.add_attempt(when, 22) # TODO: Fix the port being accessed

    # if we're doing totals, then add them
    if len(tfile) > 0:
        date = get_month_and_year(when)
        record = TOTALS.get(date)
        if record is None:
            record = 0
            TOTALS[date] = record
        record = record + 1
        TOTALS[date] = record

def get_access_source(line):
    # return from any P2P access attempts
    if re.search(r':52017', line): return
    # first see if we have a datetime entry
    match = access_attempt_with_datetime_re.search(line)
    if match:
        source = match.group(1)
        when = convert_month_first(match.group(3))
    else:
        match = access_attempt_re.search(line)
        source = match.group(1)
        when = default_datetime
    # get the geoip information for the source
    geoip = GI.country_name_by_addr(source)
    store_access_detail(geoip, source, when)

def process_line(line):
    line = line.strip("\r\n")
    debug("read=%s" % line)
    # if the line contains "(PST)" then it has a default date stamp
    # if re.search(DEFAULT_TIMESTAMP_RE, line):
    if default_timestamp_re.search(line):
        get_default_datetime(line)
    elif access_attempt_re.search(line):
        get_access_source(line)

def update_top_offenders(top_offenders_list, count, country):
    # find a country with fewer offenses and insert the supplied country
    index = 0
    while top_offenders_list[index] is not None and top_offenders_list[index][0] >= count and index < len(top_offenders_list):
        print "Updating %d for %s (%d)" % (index, country, count)
        index = index + 1
    if index < len(top_offenders_list):
        current = len(top_offenders_list) - 1
        while current > index and current > 1:
            top_offenders_list[current] = top_offenders_list[current - 1]
            current = current - 1
        print "Inserting %s at %d" % (country, index)
        top_offenders_list[index] = [count, country]
        

ofile = cfile = tfile = None

try:
    opts, args = getopt.getopt(sys.argv[1:], "i:o:c:t:vh",
                               [
                                   "input=",
                                   "output=",
                                   "totals=",
                                   "csv=",
                                   "verbose",
                                   "help"
                               ])
except getopt.GetoptError as err:
    print str(err)
    usage()
    sys.exit(2)

# define values
DEBUG=False

for o, a in opts:
    if o == "-v":
        DEBUG = True
    elif o in ("-h", "--help"):
        usage()
        sys.exit(0)
    elif o in ("-i", "--input"):
        ifile = a
    elif o in ("-o", "--output"):
        ofile = a
    elif o in ("-c", "--csv"):
        cfile = a
    elif o in ("-t", "--totals"):
        tfile = a
    else:
        assert False, "invalid option: %s" % o

debug("USING: ifile=%s" % ifile)

if len(ifile) == 0:
    die("missing or invalid filename: %s" % ifile)

# the ifile is read and processed into a hash
#
# the key is the source IP address
# the value an array
#
# the value array has two elements:
# * the country of origin for the IP address, and
# * the date and time of the access attempt

results = {}

show_output("Loading file: %s" % ifile)

with open(ifile) as f:
    lines = f.readlines()
    for line in lines:
        process_line(line)

old_stdout = sys.stdout
access_count = 0
most_attempts = [0, None]
single_most_attempts = [0, None, None]
longest_running_attempts = [0, None, None, None, None]
oldest = newest = None
accesses = []
top_offenders = [None, None, None, None, None]

if len(ofile) > 0:
    sys.stdout = open(ofile, "w")
    show_output("Writing to %s" % ofile)

for country in sorted(DETAILS.keys()):
    access_by_country = 0
    country_details = DETAILS.get(country)
    print "===== COUNTRY: %s (total addresses found=%d)" % (country, country_details.total_addresses)
    for address in sorted(country_details.sorted_addresses):
        address_details = country_details.for_address(address)
        if address_details.total_attempts > single_most_attempts[0]:
            single_most_attempts = (address_details.total_attempts, address, country)
        address_oldest = address_details.oldest_attempt
        address_newest = address_details.latest_attempt
        if get_number_of_days(address_newest[0], address_oldest[0]) > longest_running_attempts[0]:
            longest_running_attempts = (get_number_of_days(address_newest[0], address_oldest[0]),
                                        address_details.total_attempts, address, country,
                                        get_datestamp(address_oldest[0]),
                                        get_datestamp(address_newest[0]))
        print ""
        print "IP ADDRESS: %s [%d attempt(s)] from %s to %s" % (address, address_details.total_attempts, get_datestamp(address_oldest[0]), get_datestamp(address_newest[0]))
        print "SOURCE ADDRESS  DATE OF ACCESS"
        print "=============== ==================="
        for detail in sorted(address_details.attempts):
            if newest is None or detail[0] > newest:
                newest = detail[0]
            if oldest is None or detail[0] < oldest:
                oldest = detail[0]
            print "%15s %s" % (address, get_timestamp(detail[0]))
        access_count = access_count + address_details.total_attempts
        access_by_country = access_by_country + address_details.total_attempts
    if access_by_country > most_attempts[0]:
        most_attempts = (access_by_country, country)
    # update_top_offenders(top_offenders, access_by_country, country)
    accesses.append((country, country_details.total_addresses, access_by_country, get_datestamp(country_details.oldest_attempt), get_datestamp(country_details.newest_attempt), get_number_of_days(country_details.newest_attempt, country_details.oldest_attempt)))
    print ""
    print "TOTAL ATTEMPTS: %d" % access_by_country
    print ""
print ""
print "===== Total records: %d" % access_count
print "===== Most attempts (%d total) from country %s" % most_attempts
print "===== Most attempts (%d total) from address %s (%s)" % single_most_attempts
print "===== Longest running (%d days, %d total) accesses from address %s (%s) between %s and %s" % longest_running_attempts
print "===== Oldest record: %s" % get_timestamp(oldest)
print "===== Newest record: %s (a span of %d days)" % (get_timestamp(newest), get_number_of_days(newest, oldest))
print ""
print "===== Top %d offending countrys (by access attempts)" % len(top_offenders)
for offender in top_offenders:
    if offender is not None:
        print "===== %s (%d total access attempts)" % (offender[1], offender[0])
print ""
print "Country totals:"
print "                  COUNTRY                 ADDRS  TOTAL    OLDEST      NEWEST    # DAYS"
print "========================================  =====  =====  ==========  ==========  ======"
for access in accesses:
    print "%-40s  %5d  %5d  %s  %s %6s" % access

sys.stdout.close()

sys.stdout = old_stdout

if len(cfile) > 0:
    show_output("Writing CSV file: %s" % cfile)

    sys.stdout = open(cfile, "w")
    print "\"DATE\",\"COUNTRY\",\"IP ADDRESS\""
    for country in sorted(DETAILS.keys()):
        country_details = DETAILS.get(country)
        for address in country_details.sorted_addresses:
            address_details = country_details.for_address(address)
            for detail in address_details.attempts_sorted_by_date:
                print "\"%s\",\"%s\",\"%s\"" % (get_timestamp(detail[0]), country, address)
    sys.stdout.close()
    sys.stdout = old_stdout

if len(tfile) > 0:
    show_output("Writing totals file: %s" % tfile)

    sys.stdout = open(tfile, "w")
    print "\"DATE\",\"ATTEMPTS\""
    for date in sorted(TOTALS.keys()):
        record = TOTALS.get(date)
        print "\"%s\",\"%s\"" % (date, record)
    sys.stdout.close()
    sys.stdout = old_stdout

show_output("Finished!")
